  Практическая работа 9.5
  
  Задание 1: используя рекурсию, выведите в консоль в строку с пробелами между числами последовательность Фибоначчи, начиная с нулевого значения до числа 2 584.
  Решение (программа Task_1).
  В главной функции объявлена переменная temp типа uint16_t (диапазон значений 0...65535) для хранения промежуточных результатов вычислений. Также объявлена переменная n типа uint8_t для хранения текущей позиции (т.е. чисел, от которых нужно вычислить функцию Фибоначчи). Ей присвоено нулевое значение. После вывода заголовка "Числа Фибоначчи" идёт цикл while, который будет повторяться до тех пор, пока вычисленное значение, хранящееся в переменной temp, будет меньше указанного в задании (т.е. 2584). В цикле производится вызов функции Calculation(), которая и вычисляет нужное значение для каждой позиции n. Далее организован вывод на экран каждой позиции (указнной в скобках) и соответствующей ей функции Фибоначчи. Результаты (для разных позиций) выводятся в столбик для удобства их чтения. После этого значение позиции n инкрементируется на 1. Таким образом, будут проведены вычисления для всех позиций, начиная от 0 и заканчивая той позицией, для которой её функция Фибоначчи будет равна 2584 (по результатам работы программы это 18).
  Процедура Calculation(), производящая расчет функции Фибоначчи для каждой позиции, принимает номер позиции (переменная n типа uint8_t) и возвращет вычисленное значение типа uint16_t. Для хранения вычисляемых значений внутри процедуры объявлена локальная переменная temp типа uint16_t. Так как по формуле расчёта функции Фибоначчи для значений 0 и 1 результатми являются те же самые 0 и 1 соответственно (и вычисления не должны проводиться во избежание появления некорректных результатов), то производится проверка входного значения на 0 или 1 (с равным успехом можно было бы написать в условии if(n<2)). В этом случае входные значения n возвращается из процедуры без какой-либо обработки, и процедура на этом завершается. Если же входное значение не 0 и не 1, производится вычисление по формуле Фибоначчи (f(n)=f(n-1)+f(n-2), где f(n-1) и f(n-2) - значения функции Фибоначчии, вычисленные ранее на предыдущих итерациях), для чего процедура Calculation() два раза вызывается изнутри самой себя, т.е. осуществляется рекурсия. После этого возвращается вычисленное значение temp.

  Задание 2. Используя рекурсивную функцию, написать следующую программу. Объявить переменную и введите в неё случайное значение из консоли. Эта переменная должна открывать клетки — если значение в ней совпадёт со значением закрытых клеток в игре, будет выполнено условие об открытии соседних клеток с таким же значением. Объявите двумерный массив 5 × 5 и заполните его числами — можно использовать консоль для ввода чисел или заполнять массив непосредственно в коде программы. Числа положительные, целые, от нуля до 127 включительно. Изначально все данные массива недоступны пользователю. Во втором массиве размером 5 × 5 хранятся сведения об открытии пользователем клеток первого массива. Если пользователь открыл клетку, элемент второго массива принимает значение 1, если клетка закрыта — значение 0. Если пользователь открыл клетку, совпадающую с первой переменной, автоматически должны открыться все клетки с таким же значением.
  Решение (программа Task_1), первый способ.
  Обявляются три двумерных массива, имеющих одинаковую размерность 5 × 5. Они объявляются как глобальные переменные, так как должны быть доступны всем функциям, в том числе и при рекурсивном вызове. Объявляется исходный массив Data_Chart типа char, содержащий значения букв в коде ASCII. Он недоступен для просмотра пользователем, т.е. при вызове консольного приложения он не отображается в нём. Затем объявлен массив Flag_Chart типа uint8_t, предназначенный для хранения сведений об открытии пользователем ячеек массива Data_Chart. Изначально заполнен нулями. Далее объявляется массив Rendered_Chart, который отображается на экране при работе консольного приложения и показывает отгаданные пользователем ячейки. Также изначально заполнен нулями. 
  В главной функции содержится вызов процедуры View(), принимающей массив Rendered_Chart для вывода его содержимого на экран. Так как на этом этапе ещё ни одна ячейка не отгадана, он будет представлять собой пустые клетки. Далее вызывается процедура Game, в которой происходит основная часть работы программы. После её завершения завершается и вся программа.
  View() - процедура отображения заданного двумерного массива и выравнивания отображаемых символов. Принимает в качестве аргумента двумерный массив Rendered_Chart. Содержит двойной цикл по преременным i, j для доступа к строкам и элементам массива. Каждый элемент проверяется на нулевое значение (т.е. в нём не записан никакой символ). Если это так, выводится пробел с разделительной чертой. Если нет (т.е. есть какой-то символ в данной ячейке), то выводится этот символ и разделительная черта, без пробела. Поэтому выводимые ячейки будут выравнены по горизонтали независимо от того, содержат ли они какой-либо символ или нет. После прохода каждой строки производится переход отображаемых ячеек на новую строку при помощи функции puts(), которая также добавляет разделительную черту в конце строки.
  Game() - рекурсивная процедура, выполняющая основные функции программы. Процедура не принимает значений и возвращает значение типа uint8_t. В ней объявлены две локальных переменных: Letter типа char, в которую будут записаны вводимые пользователем символы, и переменная sum типа uint8_t, используемая для определения количества отгаданных элементов. После вывода строки "Введите букву" и считывания этой буквы посредством scanf(), производится очистка экрана посредством процедуры system("cls"). Это необходимо для того, чтобы введённый символ и поле с отгаданными ячейками заменялись каждый раз после ввода очередного символа, а не шли друг за другом, загромождая экран. Затем начинается двойной цикл по преременным i, j для доступа к строкам и элементам массива, в котором значение введенного элемента в переменной Letter проверяется на равенство с элементом, расположенным в ячейке Data_Chart с теми же координатами. В этом же условии через оператор ИЛИ проверяется, не содержится ли 1 в ячейке массива Flag_Chart (с теми же координатами), т.е. была ли эта ячейка открыта раньше. Если хотя бы одно из этих условий будет выполнено, в ячейку массива Rendered_Chart будет записано содержимое соответствующее значение из ячейки Data_Chart, кот
 
 
  
